{"name":"Solução de Exercícios - Computação Gráfica","tagline":"João Batista - 2012919966","body":"# 1. Conceitos Iniciais  \r\n\r\n## 1.1. Programa \"Quadrados 4\"  \r\n### a) Arquivos  \r\n* [quadrados4.c](https://www.dropbox.com/s/6795tle7549ujry/quadrados4.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0) \r\n \r\n### b) Como compilar e executar          \r\n\r\n    $ make quadrados4\r\n    $ quadrados4\r\n\r\n### c) Código\r\n\r\n```c\r\n\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nvoid display(void);\r\nvoid timer(int);\r\nvoid keyboard(unsigned char key, int x, int y);\r\n\r\n/* cores do quadrado */\r\nGLfloat r=1.0, g=0.5, b=0.0;\r\nGLfloat a, u, c;\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (argv[0]);\r\n\t// inicia um temporizador. após 33ms ativa a funcao timer\r\n\tglutTimerFunc(33, timer, 1);\r\n\tglClearColor(1.0, 1.0, 1.0, 0.0);\r\n\tglShadeModel (GL_FLAT);\r\n\tglOrtho (0, 1, 0, 1, -1 ,1);\r\n\tglutDisplayFunc(display);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\nvoid timer(int value){\r\n\tr=r+0.01;\r\n\tg=g+0.01;\r\n\tb=b+0.01;\r\n\r\n\ta=r+0.5; \r\n\tu=g+0.5; \r\n\tc=b+0.5;\r\n\r\n\tif(a>1) a-=1;\r\n\tif(u>1) u-=1;\r\n\tif(c>1) c-=1;\r\n\r\n\tif(r>1) r=0;\r\n\tif(g>1) g=0;\r\n\tif(b>1) b=0;\r\n\tglutPostRedisplay();\r\n\tglutTimerFunc(33, timer, 1);\r\n}\r\n\r\nvoid display(void){\r\n\tint i;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglColor3f (r, g, b);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2f(0.1,0.1);\r\n\tglVertex2f(0.5,0.1);\r\n\tglVertex2f(0.5,0.5);\r\n\tglVertex2f(0.1,0.5);\r\n\tglEnd();\r\n\r\n\tglColor3f (a, u, c);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2f(0.25,0.25);\r\n\tglVertex2f(0.75,0.25);\r\n\tglVertex2f(0.75,0.75);\r\n\tglVertex2f(0.25,0.75);\r\n\tglEnd();\r\n\r\n\tglColor3f (0.25,0.2,0.8);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2f(0.75,0.75);\r\n\tglVertex2f(1,0.75);\r\n\tglVertex2f(1,1);\r\n\tglVertex2f(0.75,1);\r\n\tglEnd();\r\n\r\n\tglColor3f (0.1,0.5,0.2);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2f(0.3,0.3);\r\n\tglVertex2f(0.2,0.3);\r\n\tglVertex2f(0.2,0.2);\r\n\tglVertex2f(0.3,0.2);\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n\tglutSwapBuffers(); \r\n}\r\n```\r\n   \r\n## 1.2. Programa \"Quadrados Color\"  \r\n### a) Arquivos  \r\n* [quadradoscolor.c](https://www.dropbox.com/s/3o93c37an7fe0n0/quadradoscolor.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar  \r\n\r\n    $ make quadradoscolor  \r\n    $ quadradoscolor  \r\n   \r\n### c) Código\r\n   \r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\nvoid display(void);\r\nvoid timer(int);\r\nvoid keyboard(unsigned char key, int x, int y);\r\n\r\nGLfloat rad(int teta){return (3.14159265359*teta)/180.;}\r\n/* cores do quadrado */\r\nGLfloat r[4],\tg[4],\tb[4];\r\nint h[4] = {0.0,50.0,100.0,150.0};\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (argv[0]);\r\n\t// inicia um temporizador. após 33ms ativa a funcao timer\r\n\tglutTimerFunc(33, timer, 1);\r\n\tglClearColor(1.0, 1.0, 1.0, 0.0);\r\n\t//glShadeModel (GL_FLAT);\r\n\tglOrtho (0, 1, 0, 1, -1 ,1);\r\n\tglutDisplayFunc(display);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\nvoid timer(int value){\r\n\t\r\n\r\n\tfor(int j=0; j<4; j++){\t\t\r\n\t\r\n\t\th[j] = h[j] + 10.;\r\n\t\tif(h[j]>=360) h[j] = h[j]%360; \r\n\t\t\t\r\n\t\tif(h[j]>=0 && h[j]<120){\t\t\t\r\n\t\t\tb[j] = .25;\r\n\t\t\tr[j] = .5 + .25*cos(rad(h[j]))/cos(rad(60)-rad(h[j]));\r\n\t\t\tg[j] = 1.5 - (r[j] + .25);\r\n\t\t}else if(h[j]<240){\r\n\t\t\tr[j] = .25;\r\n\t\t\tg[j] = .25 + .25*cos(rad(h[j])-rad(120))/cos(rad(180)-rad(h[j]));\r\n\t\t\tb[j] = 1.5 - (.25 + g[j]);\r\n\t\t}else if(h[j]<360){\r\n\t\t\tg[j] = .25;\r\n\t\t\tb[j] = .5 + .25*cos(rad(h[j])-rad(240))/cos(rad(300)-rad(h[j]));\r\n\t\t\tr[j] = 1.5 - (.25 + b[j]);\r\n\t\t}\r\n\twhile(r[j] > 1) r[j] = r[j] - 1.;\r\n\twhile(g[j] > 1) g[j] = g[j] - 1.;\r\n\twhile(b[j] > 1) b[j] = b[j] - 1.;\r\n\r\n\t}\r\n\tglutPostRedisplay();\r\n\tglutTimerFunc(33, timer, 1);\r\n}\r\n\r\nvoid display(void){\r\n\tint i;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglBegin(GL_POLYGON);\r\n\tglColor3f (r[0], g[0], b[0]);\r\n\tglVertex2f(0.1,0.1);\r\n\tglColor3f (r[1], g[1], b[1]);\r\n\tglVertex2f(0.9,0.1);\r\n\tglColor3f (r[2], g[2], b[2]);\r\n\tglVertex2f(0.9,0.9);\r\n\tglColor3f (r[3], g[3], b[3]);\r\n\tglVertex2f(0.1,0.9);\r\n\tglEnd();\r\n\r\n\tglFlush();\r\n\tglutSwapBuffers(); \r\n}\r\n```\r\n\r\n# 2. Desenhando Linhas e Pontos  \r\n## 2.1. Programa \"Quadrado\"  \r\n### a) Arquivos  \r\n* [quadrado.c](https://www.dropbox.com/s/dq2pzhiwl0n4w4p/quadrado.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar  \r\n\r\n    $ make quadrado  \r\n    $ quadrado  \r\n\r\n### c) Código\r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid keyboard(unsigned char key, int x, int y);\r\nGLfloat r = 1.0, b = 0.0;\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (\"Desenhando uma linha\");\r\n\tinit();\r\n\tglutDisplayFunc(display); \r\n\tglutKeyboardFunc(keyboard);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\n\r\nvoid init(void){\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n\tglOrtho (0, 256, 0, 256, -1 ,1);\r\n}\r\n\r\nvoid display(void){\r\n\tint i;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglColor3f (r, 0.0, b);\r\n\tglBegin(GL_LINES);\r\n\tglVertex2i(30,30);  glVertex2i(226,30);\r\n\tglBegin(GL_LINES);\r\n\tglVertex2i(226,30);  glVertex2i(226,226);\r\n\tglBegin(GL_LINES);\r\n\tglVertex2i(226,226);  glVertex2i(30,226);\r\n\tglBegin(GL_LINES);\r\n\tglVertex2i(30,226);  glVertex2i(30,30);\r\n\r\n\tglEnd();\r\n\tglFlush();\r\n}\r\n\r\nvoid keyboard(unsigned char key, int x, int y){\r\n\r\n\tswitch (key) {\r\n\t\tcase 'b':\r\n\t\t\tr = 0.0;\r\n\t\t\tb = 1.0;\r\n\t\t\tbreak;\r\n\t\tcase 'r':\r\n\t\t\tr = 1.0;\r\n\t\t\tb = 0.0;\r\n\t\t\tbreak;\r\n  \tcase 27:\r\n\t\t\texit(0);\r\n\t\tbreak;\r\n  }\r\n\tdisplay();\r\n}\r\n```\r\n\r\n## 2.2. Programa \"Bresenham linhas\"  \r\n### a) Arquivos  \r\n* [bresenhamlinha.c](https://www.dropbox.com/s/drimz5ezrs7t0le/bresenhamlinha.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar  \r\n\r\n    $ make bresenhamlinha  \r\n    $ bresenhamlinha  \r\n\t\r\n### c) Código\r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid setPixel(int x, int y);\r\nvoid bresenham(int x1, int y1, int x2, int y2);\r\nint Sinal(int x){ if(x >= 0) return 1; else return -1;}\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (\"Desenhando uma linha\");\r\n\tinit();\r\n\tglutDisplayFunc(display);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\nvoid setPixel(int x, int y){  \r\n  \tglColor3f (0.0, 1.0, 0.0);\r\n  \tglBegin(GL_POINTS);\r\n  \tglVertex2i(x,y);\r\n\tglEnd();\r\n}\r\nvoid bresenham(int x1, int y1, int x2, int y2){\r\n\tint Temp, new_e, Troca; \t\r\n\tint x = x1;\r\n \tint y = y1;\r\n \tint Delta_x = abs(x2 - x1);\r\n \tint Delta_y = abs(y2 - y1);\r\n\tint s1 = Sinal(x2 - x1);\r\n\tint s2 = Sinal(y2 - y1);\r\n \tif(Delta_y > Delta_x){\r\n   \t\tTemp = Delta_x;\r\n   \t\tDelta_x = Delta_y;\r\n   \t\tDelta_y = Temp;\r\n   \t\tTroca = 1;\r\n\t}\r\n\telse{\r\n\t   Troca = 0;\r\n \t}\r\n\tnew_e = 2*Delta_y - Delta_x;\r\n \tfor(int i=1; i<= Delta_x; i++){\r\n   \t\tsetPixel(x,y);\r\n   \t\twhile (new_e >= 0){\r\n     \t\tif(Troca == 1){\r\n\t       \t\tx = x + s1;\r\n     \t\t}\r\n\t     \telse{\r\n       \t\t\ty = y + s2;\r\n     \t\t}\r\n     \t\tnew_e = new_e - 2*Delta_x;\r\n   \t\t}\r\n\r\n   \t\tif(Troca == 1){\r\n     \t\ty = y + s2;\r\n  \t\t}\r\n   \t\telse{\r\n     \t\tx = x + s1;\r\n   \t\t}\r\n   \t\tnew_e = new_e + 2*Delta_y;\r\n \t}\r\n}\r\n\r\nvoid init(void){\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n\tglOrtho (0, 256, 0, 256, -1 ,1);\r\n}\r\n\r\nvoid display(void){\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tbresenham(40,200,200,10);\r\n\tglFlush();\r\n}\r\n```\r\n \r\n## 2.3. Programa \"Bresenham Circunferências\"  \r\n### a) Arquivos  \r\n* [bresenhamcircu.c](https://www.dropbox.com/s/7vv3cle1cdsn2fu/bresenhamcircu.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar  \r\n\r\n    $ make bresenhamcircu  \r\n    $ bresenhamcircu  \r\n\r\n### c) Código\r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid setPixel(int x, int y);\r\nvoid bresenham(int x1, int y1, int x2, int y2);\r\nint Sinal(int x){ if(x >= 0) return 1; else return -1;}\r\nvoid pontosDaCircunferencia(int x, int y);\r\n\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (\"Desenhando uma linha\");\r\n\tinit();\r\n\tglutDisplayFunc(display);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\nvoid setPixel(int x, int y){  \r\n  \tglColor3f (0.0, 0.0, 1.0);\r\n  \tglBegin(GL_POINTS);\r\n  \tglVertex2i(x,y);\r\n\tglEnd();\r\n}\r\nvoid pontosDaCircunferencia(int x, int y, int x0, int y0){\r\n\tsetPixel(x+x0,y+y0);\r\n\tsetPixel(-x+x0,y+y0);\r\n\tsetPixel(x+x0,-y+y0);\r\n\tsetPixel(-x+x0,-y+y0);\r\n}\r\nvoid bresenham(int x0, int y0, int raio){\r\n\tint x = 0;\r\n\tint y = raio;\r\n\tint d = 1 - raio;\r\n\tpontosDaCircunferencia(x,y,x0,y0);\r\n\twhile(y > x){\r\n\t\tif(d < 0){\r\n\t \t\td = d + 2*x + 3;\r\n\t \t\tx = x + 1;\r\n\t\t}\r\n\t\telse{\r\n\t\t \td = d + 2*(x-y) + 5;\r\n\t\t \tx = x + 1;\r\n\t\t \ty = y - 1;\r\n\t\t}\r\n\t\tpontosDaCircunferencia(x,y,x0,y0);\r\n\t}\r\n\ty = 0;\r\n\tx = raio;\r\n\td = 1 - raio;\r\n\tpontosDaCircunferencia(x,y,x0,y0);\r\n\twhile(x > y){\r\n\t\tif(d < 0){\r\n\t \t\td = d + 2*y + 3;\r\n\t \t\ty = y + 1;\r\n\t\t}\r\n\t\telse{\r\n\t\t \td = d + 2*(y-x) + 5;\r\n\t\t \ty = y + 1;\r\n\t\t \tx = x - 1;\r\n\t\t}\r\n\t\tpontosDaCircunferencia(x,y,x0,y0);\r\n\t}\r\n}\r\n\r\nvoid init(void){\r\n  glClearColor(1.0, 1.0, 1.0, 1.0);\r\n  glOrtho (0, 256, 0, 256, -1 ,1);\r\n}\r\n\r\nvoid display(void){\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tsetPixel(128,128);\r\n\tbresenham(128,128,50);\r\n\tglFlush();\r\n}\r\n```\r\n\r\n# 3. Preenchendo regiões  \r\n## 3.1. Programa \"Seleção\"  \r\n### a) Arquivos  \r\n* [selecao.c](https://www.dropbox.com/s/fp9d35bt37ebl19/selecao.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar \r\n\r\n    $ make selecao  \r\n    $ selecao  \r\n\r\n### c) Código\r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n\r\nGLfloat r_b[4]={0.0,0.0,0.0,0.0}, g_b[4]={0.0,0.0,0.0,0.0}, b_b[4]={0.0,0.0,0.0,0.0};\r\nGLfloat r_f[4]={1.0,1.0,1.0,1.0}, g_f[4]={1.0,1.0,1.0,1.0}, b_f[4]={0.0,0.0,0.0,0.0};\r\nchar printColor;\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid keyboard(unsigned char key, int x, int y);\r\nvoid mouse(int button, int state, int x, int y);\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (\"Preenchendo regiões\");\r\n\tinit();\r\n\tglutDisplayFunc(display); \r\n\tglutKeyboardFunc(keyboard);\r\n\tglutMouseFunc(mouse);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\n\r\nvoid init(void){\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n\tglOrtho (0, 256, 0, 256, -1 ,1);  \r\n}\r\n\r\nvoid display(void){\r\n\tint i;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglDisable(GL_POLYGON_STIPPLE);\r\n\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[0], g_f[0], b_f[0]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,226);  glVertex2i(113,226);\r\n\tglVertex2i(113,143); glVertex2i(30,143); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[0], g_b[0], b_b[0]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,226);  glVertex2i(113,226);\r\n\tglVertex2i(113,143); glVertex2i(30,143); \r\n\tglEnd();\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[1], g_f[1], b_f[1]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,226); glVertex2i(226,226);\r\n\tglVertex2i(226,143); glVertex2i(143,143); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[1], g_b[1], b_b[1]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,226); glVertex2i(226,226);\r\n\tglVertex2i(226,143); glVertex2i(143,143);\r\n\tglEnd();\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[2], g_f[2], b_f[2]);\r\n\tglBegin(GL_POLYGON);  \r\n\tglVertex2i(30,113); glVertex2i(113,113);\r\n\tglVertex2i(113,30); glVertex2i(30,30); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[2], g_b[2], b_b[2]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,113); glVertex2i(113,113);\r\n\tglVertex2i(113,30); glVertex2i(30,30); \r\n\tglEnd();\r\n\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[3], g_f[3], b_f[3]);\r\n\tglPolygonStipple(tux);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,113); glVertex2i(226,113);\r\n\tglVertex2i(226,30); glVertex2i(143,30); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[3], g_b[3], b_b[3]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,113); glVertex2i(226,113);\r\n\tglVertex2i(226,30); glVertex2i(143,30); \r\n\tglEnd();\r\n\r\n\tglFlush();\r\n\tglutSwapBuffers();\r\n}\r\n\r\nvoid keyboard(unsigned char key, int x, int y){\r\n  switch (key) {\r\n\t\tcase 98:\r\n\t\t\tprintColor = 'b';\r\n\t\t\tbreak;\r\n\t\tcase 102:\r\n\t\t\tprintColor = 'f';\r\n\t\t\tbreak;\r\n\t\tcase 27:\r\n\t\t\texit(0);\r\n\t\tbreak;\r\n  }\r\n}\r\n\r\nvoid mouse(int button, int state, int x, int y){\r\n\tint n = 5;\r\n\tswitch (button) {\r\n\t\tcase GLUT_LEFT_BUTTON:\r\n\t\t\tif (state == GLUT_DOWN && printColor == 'b') {\r\n\t\t\t\tif( x>=30 & x<=113 & y>=143 & y<=226 ){\r\n\t\t\t\t\tn = 2;\r\n\t\t\t\t}else if ( x>=143 & x<=226 & y>=143 & y<=226 ){\r\n\t\t\t\t\tn = 3;\r\n\t\t\t\t}else if ( x>=30 & x<=113 & y>=30 & y<=113 ){\r\n\t\t\t\t\tn = 0;\r\n\t\t\t\t}else if ( x>=143 & x<=226 & y>=30 & y<=113 ){\r\n\t\t\t\t\tn = 1;\r\n\t\t\t\t}else break;\r\n\t\t\t\tr_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tg_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tb_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tglutPostRedisplay();\r\n\t\t\t}else if (state == GLUT_DOWN && printColor == 'f') {\r\n\t\t\t\tif( x>=30 & x<=113 & y>=143 & y<=226 ){\r\n\t\t\t\t\tn = 2;\r\n\t\t\t\t}else if ( x>=143 & x<=226 & y>=143 & y<=226 ){\r\n\t\t\t\t\tn = 3;\r\n\t\t\t\t}else if ( x>=30 & x<=113 & y>=30 & y<=113 ){\r\n\t\t\t\t\tn = 0;\r\n\t\t\t\t}else if ( x>=143 & x<=226 & y>=30 & y<=113 ){\r\n\t\t\t\t\tn = 1;\r\n\t\t\t\t}else break;\r\n\t\t\t\tr_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tg_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tb_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\t\tglutPostRedisplay();\t\t\r\n\t\t\t}\r\n\t\tbreak;\r\n\t}\r\n}\r\n```\r\n\r\n## 3.2. Programa \"Seleção\" com buffer simples  \r\n### a) Arquivos  \r\n* [selecaoSimples.c](https://www.dropbox.com/s/xlj69f5jemyl2r5/selecaoSimples.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar   \r\n\r\n    $ make selecaoSimples  \r\n    $ selecaoSimples  \r\n\r\n### c) Código  \r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n\r\nGLubyte tux[] = {\r\n};\r\n\r\nGLfloat r_b[4]={0.0,0.0,0.0,0.0}, g_b[4]={0.0,0.0,0.0,0.0}, b_b[4]={0.0,0.0,0.0,0.0};\r\nGLfloat r_f[4]={1.0,1.0,1.0,1.0}, g_f[4]={1.0,1.0,1.0,1.0}, b_f[4]={0.0,0.0,0.0,0.0};\r\nchar printColor;\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid keyboard(unsigned char key, int x, int y);\r\nvoid mouse(int button, int state, int x, int y);\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);\r\n\tglutInitWindowSize (256, 256); \r\n\tglutInitWindowPosition (100, 100); \r\n\tglutCreateWindow (\"Preenchendo regiões\");\r\n\tinit();\r\n\tglutDisplayFunc(display); \r\n\tglutKeyboardFunc(keyboard);\r\n\tglutMouseFunc(mouse);\r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\n\r\nvoid init(void){\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n\tglOrtho (0, 256, 0, 256, -1 ,1);  \r\n}\r\n\r\nvoid display(void){\r\n\tint i;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglDisable(GL_POLYGON_STIPPLE);\r\n\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[0], g_f[0], b_f[0]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,226);  glVertex2i(113,226);\r\n\tglVertex2i(113,143); glVertex2i(30,143); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[0], g_b[0], b_b[0]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,226);  glVertex2i(113,226);\r\n\tglVertex2i(113,143); glVertex2i(30,143); \r\n\tglEnd();\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[1], g_f[1], b_f[1]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,226); glVertex2i(226,226);\r\n\tglVertex2i(226,143); glVertex2i(143,143); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[1], g_b[1], b_b[1]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,226); glVertex2i(226,226);\r\n\tglVertex2i(226,143); glVertex2i(143,143);\r\n\tglEnd();\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[2], g_f[2], b_f[2]);\r\n\tglBegin(GL_POLYGON);  \r\n\tglVertex2i(30,113); glVertex2i(113,113);\r\n\tglVertex2i(113,30); glVertex2i(30,30); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[2], g_b[2], b_b[2]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(30,113); glVertex2i(113,113);\r\n\tglVertex2i(113,30); glVertex2i(30,30); \r\n\tglEnd();\r\n\r\n\r\n\tglPolygonMode(GL_BACK, GL_FILL);\r\n\tglColor3f(r_f[3], g_f[3], b_f[3]);\r\n\tglPolygonStipple(tux);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,113); glVertex2i(226,113);\r\n\tglVertex2i(226,30); glVertex2i(143,30); \r\n\tglEnd();\r\n\tglPolygonMode(GL_BACK, GL_LINE);\r\n\tglColor3f(r_b[3], g_b[3], b_b[3]);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(143,113); glVertex2i(226,113);\r\n\tglVertex2i(226,30); glVertex2i(143,30); \r\n\tglEnd();\r\n\r\n\tglFlush();\r\n\tglutSwapBuffers();\r\n}\r\n\r\nvoid keyboard(unsigned char key, int x, int y){\r\n  switch (key) {\r\n\t\tcase 98:\r\n\t\t\tprintColor = 'b';\r\n\t\t\tbreak;\r\n\t\tcase 102:\r\n\t\t\tprintColor = 'f';\r\n\t\t\tbreak;\r\n\t\tcase 27:\r\n\t\t\texit(0);\r\n\t\tbreak;\r\n  }\r\n}\r\n\r\nvoid mouse(int button, int state, int x, int y){\r\n\tint n = 5;\r\n  switch (button) {\r\n  case GLUT_LEFT_BUTTON:\r\n\t\tif (state == GLUT_DOWN && printColor == 'b') {\r\n\t\t\tif( x>=30 & x<=113 & y>=143 & y<=226 ){\r\n\t\t\t\tn = 2;\r\n\t\t\t}else if ( x>=143 & x<=226 & y>=143 & y<=226 ){\r\n\t\t\t\tn = 3;\r\n\t\t\t}else if ( x>=30 & x<=113 & y>=30 & y<=113 ){\r\n\t\t\t\tn = 0;\r\n\t\t\t}else if ( x>=143 & x<=226 & y>=30 & y<=113 ){\r\n\t\t\t\tn = 1;\r\n\t\t\t}else break;\r\n\t\t\tr_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tg_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tb_b[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tglutPostRedisplay();\r\n\t\t}else if (state == GLUT_DOWN && printColor == 'f') {\r\n\t\t\tif( x>=30 & x<=113 & y>=143 & y<=226 ){\r\n\t\t\t\tn = 2;\r\n\t\t\t}else if ( x>=143 & x<=226 & y>=143 & y<=226 ){\r\n\t\t\t\tn = 3;\r\n\t\t\t}else if ( x>=30 & x<=113 & y>=30 & y<=113 ){\r\n\t\t\t\tn = 0;\r\n\t\t\t}else if ( x>=143 & x<=226 & y>=30 & y<=113 ){\r\n\t\t\t\tn = 1;\r\n\t\t\t}else break;\r\n\t\t\tr_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tg_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tb_f[n]=(GLfloat)rand()/(RAND_MAX+1.0);\r\n\t\t\tglutPostRedisplay();\t\t\r\n\t\t}\r\n\tbreak;\r\n  }\r\n}\r\n```\r\n\r\n## 3.3. Programa \"Iniciais\" (Hexágono com as iniciais)  \r\n### a) Arquivos  \r\n* [iniciais.c](https://www.dropbox.com/s/unfk2lzinej1062/iniciais.c?dl=0)  \r\n* [Makefile](https://www.dropbox.com/s/wgqv3tpa4ow4xau/Makefile?dl=0)  \r\n\r\n### b) Como compilar e executar  \r\n\r\n    $ make iniciais  \r\n    $ iniciais  \r\n\r\n### c) Código\r\n\r\n```c\r\n#include <GL/glut.h>\r\n#include <stdlib.h>\r\n\r\nGLubyte tux[] = {\r\n0x0, 0x0,  0x0,  0x0,\r\n0x0, 0x0,  0x0,  0x0,\r\n0x0, 0x0,  0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xFE, 0x0,  0x0,\r\n0x0, 0xFE, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xC0, 0x0,  0x0,\r\n0x0, 0xFF, 0xF8, 0x0,\r\n0x0, 0xFF, 0xF8, 0x0,\r\n0x7, 0xe0, 0x3f, 0x0,\r\n0xE, 0x70, 0x3F, 0xC0,\r\n0xC, 0x30, 0x30, 0xE0,\r\n0xC, 0x30, 0x30, 0x70,\r\n0x0, 0x30, 0x30, 0xE0,\r\n0x0, 0x30, 0x3F, 0xC0,\r\n0x0, 0x30, 0x3F, 0x80,\r\n0x0, 0x30, 0x30, 0xE0,\r\n0x0, 0x30, 0x30, 0x70,\r\n0x0, 0x30, 0x30, 0x38,\r\n0xF, 0xFF, 0xFF, 0xF0,\r\n0xF, 0xFF, 0xFF, 0xE0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0,\r\n0x0, 0x0, 0x0, 0x0\r\n};\r\n\r\nGLfloat r,g,b;\r\n\r\nvoid init(void);\r\nvoid display(void);\r\nvoid hexagono();\r\n\r\nint main(int argc, char** argv){\r\n\tglutInit(&argc, argv);\r\n\tglutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB);\r\n\tglutInitWindowSize (300, 300); \r\n\tglutInitWindowPosition (200, 200); \r\n\tglutCreateWindow (\"Preenchendo regiões\");\r\n\tinit();\r\n\tglutDisplayFunc(display); \r\n\tglutMainLoop();\r\n\treturn 0;\r\n}\r\n\r\nvoid init(void){\r\n\tglClearColor(1.0, 1.0, 1.0, 1.0);\r\n\tglOrtho (0, 256, 0, 256, -1 ,1);\r\n\tr=0; g=1; b=0;\r\n}\r\n\r\nvoid display(void){\r\n\tint x = 125;\r\n\tint y = x;\r\n\tglClear(GL_COLOR_BUFFER_BIT);\r\n\tglDisable(GL_POLYGON_STIPPLE);\r\n\r\n\tglEnable(GL_POLYGON_STIPPLE);\r\n\tglColor3f(0.0, 0.0, 1.0);\r\n\tglPolygonStipple(tux);\r\n\tglBegin(GL_POLYGON);\r\n\tglVertex2i(x,y+79);\r\n\tglVertex2i(x-68,y+39);\r\n\tglVertex2i(x-68,y-39);\r\n\tglVertex2i(x,y-79);\r\n\tglVertex2i(x+68,y-39);\r\n\tglVertex2i(x+68,y+39);\r\n\tglEnd();\r\n\tglFlush();\r\n\tglutSwapBuffers();\r\n}\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}